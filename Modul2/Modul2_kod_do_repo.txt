
#include <SPI.h>
#include <MFRC522.h>
#include <U8g2lib.h>
#include <Wire.h>
#include "DHT.h"
#include <ESP32Servo.h>
#include <WiFi.h>
#include <PubSubClient.h>

//Konfiguracja pinów
#define DHTPIN      1      // Czujnik temperatury/wilgotności
#define RFID_RST    2      // Reset modułu RFID
#define RFID_SS     3      // Chip Select modułu RFID
#define SERVO_PIN   7      // Sygnał sterujący serwem
#define KONTAKTRON  8      // Czujnik otwarcia drzwi (NC/NO)
#define BUZZER      14     // Sygnalizator dźwiękowy

//Konfiguracja sieci i komunikacji z brokerem MQTT
const char* ssid = "Projekt_WIFI";
const char* password = NULL;     
const char* mqtt_server = "192.168.1.200";

//Zdefiniowanie obiektów globalnych
U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE, 20, 19);
MFRC522 mfrc522(RFID_SS, RFID_RST);
DHT dht(DHTPIN, DHT22);
Servo lockServo;
WiFiClient espClient;
PubSubClient client(espClient);

//Zmienne stanu
String timeDisplay = "--:--";	//Format czasu na ekran OLED
const String masterCardUID = "17 FF 89 04"; //UID karty podpisanej jako Mateusz

bool authorized = false;       //Sprawdzenie przyznania dostępu
bool alarmActive = false;      //Sprawdzenie czy alarm jest włączony
bool lastDoorState = LOW;      //Poprzedni stan drzwi

unsigned long authorizedTime = 0;
const unsigned long lockTimeout = 20000; //20 sekund na automatyczne zamknięcie

//Zmienne pomocnicze
float temp = 0.0, hum = 0.0;
unsigned long lastOLEDUpdate = 0;
unsigned long lastMQTTMsg = 0;
unsigned long lastDHTRead = 0;

//FUNKCJE POMOCNICZE

// Sterowanie serwomechanizmem 
void moveServo(int angle) {
  lockServo.attach(SERVO_PIN, 500, 2400);
  lockServo.write(angle);
  delay(500); 
  lockServo.detach(); //Odłaczanie serwomechanizmu po wykonaniu ruchu celem uniknięcia drgań
}

//Sygnalizacja uzbrojenia zamka dwoma krótkimi dźwiękami
void soundArming() {
  tone(BUZZER, 3500); delay(80); noTone(BUZZER);
  delay(80);
  tone(BUZZER, 3500); delay(80); noTone(BUZZER);
}

//Obsługa komunikatów dystrybuowanych przez MQTT
void mqttCallback(char* topic, byte* payload, unsigned int length) {
  String msg = "";
  for (int i = 0; i < length; i++) msg += (char)payload[i];
  
  // Synchronizacja czasu
  if (String(topic) == "inzynierka/plytka2/time") {
    timeDisplay = msg;
  }
  
  //Operacja zdalnego otwarcia zamka z dashboardu
  if (String(topic) == "inzynierka/plytka2/out" && msg == "1") {
    authorized = true; 
    authorizedTime = millis(); 
    if(alarmActive) {
      alarmActive = false;
      client.publish("inzynierka/plytka2/alarm", "0"); //Reset alarmu
    }
    moveServo(90); //Otwarcie zamka
  }
}

//Konfiguracja połączenia z brokerem MQTT
void reconnect() {
  static unsigned long lastAttempt = 0;

  //Sprawdzenie stanu połączenia i ponowienie próby po 5 sekundach jeśli połączenie się nie powiodło
  if (!client.connected() && millis() - lastAttempt > 5000) {
    lastAttempt = millis(); //Zapisanie czasu aktualnej próby

  //Próba połączenia z brokerem unikalnym identyfikatorem klienta i subskrypcja tematów sterujących po sukcesie oraz uzależnienie zamka 
    if (client.connect("ESP32_Lock_P2")) {
      client.subscribe("inzynierka/plytka2/out");
      client.subscribe("inzynierka/plytka2/time");
    }
  }
}

//SETUP

void setup() {
  //Inicjalizacja wyjść/wejść
  pinMode(BUZZER, OUTPUT);
  pinMode(KONTAKTRON, INPUT_PULLUP); 

  // Inicjalizacja peryferiów
  Wire.begin(19, 20);
  Wire.setClock(400000); 
  u8g2.begin();
  
  dht.begin();
  
  SPI.begin(23, 21, 22, RFID_SS);
  mfrc522.PCD_Init();

  ESP32PWM::allocateTimer(1);
  lockServo.setPeriodHertz(50);
  moveServo(0); // Pozycja początkowa (zamknięte)

  //Konfiguracja połączenia z AP na RPI i brokerem MQTT na porcie 1883
  WiFi.begin(ssid, password);
  client.setServer(mqtt_server, 1883);
  client.setCallback(mqttCallback);
}

//GŁÓWNA PĘTLA
void loop() {
  if (WiFi.status() != WL_CONNECTED) {
  //Jeśli połączenie z WIFI nieudane spróbuj ponownie 
  }
  reconnect();
  client.loop();

  unsigned long currentMillis = millis();

  //Odczyt temperatury i wilgoci z DHT22 co 3 sekundy
  if (currentMillis - lastDHTRead > 3000) {
    temp = dht.readTemperature();
    hum = dht.readHumidity();
    lastDHTRead = currentMillis;
  }

  //Wykrywanie włamania
  bool currentDoorOpen = (digitalRead(KONTAKTRON) == HIGH);

  //Wykrycie otwarcia drzwi
  if (currentDoorOpen && lastDoorState == LOW) {
    if (!authorized) {
      alarmActive = true; 
  //Publikacja komunikatu przez MQTT jeśli drzwi otwarte nieprawidłowo
      client.publish("inzynierka/plytka2/alarm", "1"); // ALARM! 
    }
  }

  //Wykrycie zamknięcia drzwi 
  if (!currentDoorOpen && lastDoorState == HIGH) 
  //Ryglowanie zamka jeśli wejście legalne i jeśli działa alarm
  {
    if (authorized || alarmActive) {
      moveServo(0); // Automatyczne ryglowanie
      if (authorized) soundArming();
      authorized = false;
    }
  }
  lastDoorState = currentDoorOpen;

  //Wywołanie automatycznego ryglowania jeśli drzwi nie zostały otwarte po 20 sekundach
  if (authorized && (currentMillis - authorizedTime >= lockTimeout)) {
    moveServo(0); 
    soundArming();
    authorized = false;
  }

  //Obsługa RFID
  // Sprawdzenie obecności nowej karty w polu RF i próba odczytu jej UID
  if (mfrc522.PICC_IsNewCardPresent() && mfrc522.PICC_ReadCardSerial()) {
    String readUID = ""; //Bufor na sformatowanie identyfikatora

    //Konwersja bajtów odczytanych z karty na format szesnastobitowy
    for (byte i = 0; i < mfrc522.uid.size; i++)
 
    //Dodanie wiodącego zera dla wartości poniżej 0x10 (np. A na 0A) dla zachowania formatu
    {
      readUID += String(mfrc522.uid.uidByte[i] < 0x10 ? "0" : "");
      readUID += String(mfrc522.uid.uidByte[i], HEX);

    // Dodanie spacji między bajtami dla zwiększenia czytelności
      if (i < mfrc522.uid.size - 1) readUID += " ";
    }
    //Normaliazcja do wielkich liter
    readUID.toUpperCase();

    //Przesyłanie komunikatu o próbie dostępu za pomocą MQTT
    String rfidJson = "{\"uid\":\"" + readUID + "\"}";
    client.publish("inzynierka/plytka2/access", rfidJson.c_str());

    //Weryfikacja czy UID karty jest poprawne
    if (readUID == masterCardUID) {
      authorized = true; 

    //Znacznik czasu odliczania 20 sekund na wejście dla zamka
      authorizedTime = currentMillis; 
   
    //Dezaktywacja alarmu jeśli przyłożono kart o poprawnym UID
      if(alarmActive) {
        alarmActive = false;
        client.publish("inzynierka/plytka2/alarm", "0"); //Wysłanie komunikatu o wyłączeniu alarmu
      }

    //Sygnał dźwiękowy akceptacji
      noTone(BUZZER); //Wyłączenie dźwięku alarmu jeśli był aktywny
      tone(BUZZER, 2000); delay(150); noTone(BUZZER); 
      moveServo(90); //Fizyczne otwarcie zamka
    }

    //Zakończenie komunikacji z kartą
    mfrc522.PICC_HaltA();
    mfrc522.PCD_StopCrypto1();
  }

  //Wysyłanie obiektu JSON na broker MQTT co dwie sekundy
  if (currentMillis - lastMQTTMsg > 2000) {
    lastMQTTMsg = currentMillis;
    String json = "{\"t\":" + String(temp, 1) + 
                  ",\"h\":" + String(hum, 0) + 
                  ",\"alarm\":" + String(alarmActive) + "}";
    client.publish("inzynierka/plytka2/in", json.c_str());
  }

  //Sygnalizacja alarmu
  if (alarmActive) {
    if ((currentMillis / 150) % 2 == 0) tone(BUZZER, 2800); 
    else tone(BUZZER, 3800);
  } else {
    noTone(BUZZER);
  }

  //Odświeżanie interfejsu OLED
  if (currentMillis - lastOLEDUpdate > 100) {
    lastOLEDUpdate = currentMillis;
    u8g2.clearBuffer();
    
    //Dodanie paska statusu informującego o wilgoci i temperaturze na OLED
    u8g2.setFont(u8g2_font_5x7_tf);
    u8g2.setCursor(0, 8);
    u8g2.print("T: "); u8g2.print(temp, 1); u8g2.print("C  H: "); u8g2.print(hum, 0); u8g2.print("%");
    u8g2.drawLine(0, 10, 128, 10);

    //Obsługa komunikatów o statusie zamka 
    u8g2.setFont(u8g2_font_7x14_tf);
    if (alarmActive) {
      u8g2.drawStr(15, 32, "!!! ALARM !!!");
    } else if (authorized) {
      int timeLeft = (lockTimeout - (currentMillis - authorizedTime)) / 1000;
      u8g2.setCursor(5, 32); u8g2.print("OTWARTE: "); u8g2.print(timeLeft); u8g2.print("s");
    } else {
      u8g2.drawStr(10, 32, "ZAMEK UZBROJONY");
    }

    //Dodanie daty, godziny oraz statusów komunikacji WIFI i MQTT w dolnej części wyświetlacza
    u8g2.drawLine(0, 52, 128, 52);
    u8g2.setFont(u8g2_font_4x6_tf);
    u8g2.setCursor(0, 62); u8g2.print(timeDisplay);

    if (WiFi.status() == WL_CONNECTED) {
      // Ikona WiFi
      u8g2.drawCircle(120, 59, 1, U8G2_DRAW_ALL);
      u8g2.drawCircle(120, 59, 3, U8G2_DRAW_UPPER_RIGHT | U8G2_DRAW_UPPER_LEFT);
    }
    
    u8g2.setCursor(105, 62); u8g2.print("M");
    if (!client.connected()) {
      u8g2.drawLine(104, 62, 110, 56); //Przekreślenie ikony przy braku komunikacji MQTT
    }

    u8g2.sendBuffer();
  }
}